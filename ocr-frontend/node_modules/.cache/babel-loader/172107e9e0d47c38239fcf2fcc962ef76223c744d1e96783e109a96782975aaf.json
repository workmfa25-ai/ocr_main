{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPatch = applyPatch;\nexports.applyPatches = applyPatches;\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/;\nvar /*istanbul ignore start*/\n_distanceIterator = _interopRequireDefault(require(\"../util/distance-iterator\"))\n/*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\n/*istanbul ignore end*/\nfunction applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/\n  var /*istanbul ignore end*/\n  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/)(uniDiff);\n  }\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n    delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n    hunks = uniDiff.hunks,\n    compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/\n    {\n      return /*istanbul ignore end*/line === patchContent;\n    },\n    errorCount = 0,\n    fuzzFactor = options.fuzzFactor || 0,\n    minLine = 0,\n    offset = 0,\n    removeEOFNL,\n    addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n        operation = line.length > 0 ? line[0] : ' ',\n        content = line.length > 0 ? line.substr(1) : line;\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n      maxLine = lines.length - hunk.oldLines,\n      localOffset = 0,\n      toPos = offset + hunk.oldStart - 1;\n    var iterator = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _distanceIterator\n    /*istanbul ignore end*/[/*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/])(toPos, minLine, maxLine);\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n  var diffOffset = 0;\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n      _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n        operation = line.length > 0 ? line[0] : ' ',\n        content = line.length > 0 ? line.substr(1) : line,\n        delimiter = _hunk.linedelimiters && _hunk.linedelimiters[j] || '\\n';\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/)(uniDiff);\n  }\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}","map":{"version":3,"names":["_parse","require","_distanceIterator","_interopRequireDefault","applyPatch","source","uniDiff","options","arguments","length","undefined","parsePatch","Array","isArray","Error","lines","split","delimiters","match","hunks","compareLine","lineNumber","line","operation","patchContent","errorCount","fuzzFactor","minLine","offset","removeEOFNL","addEOFNL","hunkFits","hunk","toPos","j","content","substr","i","maxLine","oldLines","localOffset","oldStart","iterator","diffOffset","_i","_hunk","_toPos","newLines","delimiter","linedelimiters","splice","previousOperation","pop","push","_k","join","applyPatches","currentIndex","processIndex","index","complete","loadFile","err","data","updatedContent","patched"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\patch\\apply.js"],"sourcesContent":["import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters && hunk.linedelimiters[j] || '\\n';\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
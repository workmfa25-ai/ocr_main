{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __importStar(require(\"diff\"));\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n  DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n  DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n  DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType || (exports.DiffType = DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n  DiffMethod[\"CHARS\"] = \"diffChars\";\n  DiffMethod[\"WORDS\"] = \"diffWords\";\n  DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n  DiffMethod[\"LINES\"] = \"diffLines\";\n  DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n  DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n  DiffMethod[\"CSS\"] = \"diffCss\";\n  DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod || (exports.DiffMethod = DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = value => {\n  if (value === '') return [];\n  const lines = value.replace(/\\n$/, '').split('\\n');\n  return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n  const diffArray = jsDiff[compareMethod](oldValue, newValue);\n  const computedDiff = {\n    left: [],\n    right: []\n  };\n  diffArray.forEach(({\n    added,\n    removed,\n    value\n  }) => {\n    const diffInformation = {};\n    if (added) {\n      diffInformation.type = DiffType.ADDED;\n      diffInformation.value = value;\n      computedDiff.right.push(diffInformation);\n    }\n    if (removed) {\n      diffInformation.type = DiffType.REMOVED;\n      diffInformation.value = value;\n      computedDiff.left.push(diffInformation);\n    }\n    if (!removed && !added) {\n      diffInformation.type = DiffType.DEFAULT;\n      diffInformation.value = value;\n      computedDiff.right.push(diffInformation);\n      computedDiff.left.push(diffInformation);\n    }\n    return diffInformation;\n  });\n  return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n * @param showLines lines that are always shown, regardless of diff\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0, showLines = []) => {\n  let diffArray = [];\n  // Use diffLines for strings, and diffJson for objects...\n  if (typeof oldString === 'string' && typeof newString === 'string') {\n    diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n      newlineIsToken: false,\n      ignoreWhitespace: false,\n      ignoreCase: false\n    });\n  } else {\n    diffArray = diff.diffJson(oldString, newString);\n  }\n  let rightLineNumber = linesOffset;\n  let leftLineNumber = linesOffset;\n  let lineInformation = [];\n  let counter = 0;\n  const diffLines = [];\n  const ignoreDiffIndexes = [];\n  const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n    const lines = constructLines(value);\n    return lines.map((line, lineIndex) => {\n      const left = {};\n      const right = {};\n      if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) || evaluateOnlyFirstLine && lineIndex !== 0) {\n        return undefined;\n      }\n      if (added || removed) {\n        let countAsChange = true;\n        if (removed) {\n          leftLineNumber += 1;\n          left.lineNumber = leftLineNumber;\n          left.type = DiffType.REMOVED;\n          left.value = line || ' ';\n          // When the current line is of type REMOVED, check the next item in\n          // the diff array whether it is of type ADDED. If true, the current\n          // diff will be marked as both REMOVED and ADDED. Meaning, the\n          // current line is a modification.\n          const nextDiff = diffArray[diffIndex + 1];\n          if (nextDiff && nextDiff.added) {\n            const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n            if (nextDiffLines) {\n              const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n              const {\n                value: rightValue,\n                lineNumber,\n                type\n              } = nextDiffLineInfo[0].right;\n              // When identified as modification, push the next diff to ignore\n              // list as the next value will be added in this line computation as\n              // right and left values.\n              ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n              right.lineNumber = lineNumber;\n              if (left.value === rightValue) {\n                // The new value is exactly the same as the old\n                countAsChange = false;\n                right.type = 0;\n                left.type = 0;\n                right.value = rightValue;\n              } else {\n                right.type = type;\n                // Do char level diff and assign the corresponding values to the\n                // left and right diff information object.\n                if (disableWordDiff) {\n                  right.value = rightValue;\n                } else {\n                  const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                  right.value = computedDiff.right;\n                  left.value = computedDiff.left;\n                }\n              }\n            }\n          }\n        } else {\n          rightLineNumber += 1;\n          right.lineNumber = rightLineNumber;\n          right.type = DiffType.ADDED;\n          right.value = line;\n        }\n        if (countAsChange && !evaluateOnlyFirstLine) {\n          if (!diffLines.includes(counter)) {\n            diffLines.push(counter);\n          }\n        }\n      } else {\n        leftLineNumber += 1;\n        rightLineNumber += 1;\n        left.lineNumber = leftLineNumber;\n        left.type = DiffType.DEFAULT;\n        left.value = line;\n        right.lineNumber = rightLineNumber;\n        right.type = DiffType.DEFAULT;\n        right.value = line;\n      }\n      if ((showLines === null || showLines === void 0 ? void 0 : showLines.includes(`L-${left.lineNumber}`)) || (showLines === null || showLines === void 0 ? void 0 : showLines.includes(`R-${right.lineNumber}`)) && !diffLines.includes(counter)) {\n        diffLines.push(counter);\n      }\n      if (!evaluateOnlyFirstLine) {\n        counter += 1;\n      }\n      return {\n        right,\n        left\n      };\n    }).filter(Boolean);\n  };\n  diffArray.forEach(({\n    added,\n    removed,\n    value\n  }, index) => {\n    lineInformation = [...lineInformation, ...getLineInformation(value, index, added, removed)];\n  });\n  return {\n    lineInformation,\n    diffLines\n  };\n};\nexports.computeLineInformation = computeLineInformation;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","computeLineInformation","DiffMethod","DiffType","diff","require","jsDiff","constructLines","lines","replace","split","computeDiff","oldValue","newValue","compareMethod","CHARS","diffArray","computedDiff","left","right","forEach","added","removed","diffInformation","type","ADDED","push","REMOVED","DEFAULT","oldString","newString","disableWordDiff","lineCompareMethod","linesOffset","showLines","diffLines","trimRight","newlineIsToken","ignoreWhitespace","ignoreCase","diffJson","rightLineNumber","leftLineNumber","lineInformation","counter","ignoreDiffIndexes","getLineInformation","diffIndex","evaluateOnlyFirstLine","map","line","lineIndex","includes","countAsChange","lineNumber","nextDiff","nextDiffLines","nextDiffLineInfo","rightValue","filter","Boolean","index"],"sources":["D:/Workspace/ocr_main/ocr-frontend/node_modules/react-diff-viewer-continued/lib/src/compute-lines.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __importStar(require(\"diff\"));\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n    DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n    DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType || (exports.DiffType = DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n    DiffMethod[\"CHARS\"] = \"diffChars\";\n    DiffMethod[\"WORDS\"] = \"diffWords\";\n    DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n    DiffMethod[\"LINES\"] = \"diffLines\";\n    DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n    DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n    DiffMethod[\"CSS\"] = \"diffCss\";\n    DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod || (exports.DiffMethod = DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = (value) => {\n    if (value === '')\n        return [];\n    const lines = value.replace(/\\n$/, '').split('\\n');\n    return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n    const diffArray = jsDiff[compareMethod](oldValue, newValue);\n    const computedDiff = {\n        left: [],\n        right: [],\n    };\n    diffArray.forEach(({ added, removed, value }) => {\n        const diffInformation = {};\n        if (added) {\n            diffInformation.type = DiffType.ADDED;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n        }\n        if (removed) {\n            diffInformation.type = DiffType.REMOVED;\n            diffInformation.value = value;\n            computedDiff.left.push(diffInformation);\n        }\n        if (!removed && !added) {\n            diffInformation.type = DiffType.DEFAULT;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n            computedDiff.left.push(diffInformation);\n        }\n        return diffInformation;\n    });\n    return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n * @param showLines lines that are always shown, regardless of diff\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0, showLines = []) => {\n    let diffArray = [];\n    // Use diffLines for strings, and diffJson for objects...\n    if (typeof oldString === 'string' && typeof newString === 'string') {\n        diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n            newlineIsToken: false,\n            ignoreWhitespace: false,\n            ignoreCase: false,\n        });\n    }\n    else {\n        diffArray = diff.diffJson(oldString, newString);\n    }\n    let rightLineNumber = linesOffset;\n    let leftLineNumber = linesOffset;\n    let lineInformation = [];\n    let counter = 0;\n    const diffLines = [];\n    const ignoreDiffIndexes = [];\n    const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n        const lines = constructLines(value);\n        return lines\n            .map((line, lineIndex) => {\n            const left = {};\n            const right = {};\n            if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) ||\n                (evaluateOnlyFirstLine && lineIndex !== 0)) {\n                return undefined;\n            }\n            if (added || removed) {\n                let countAsChange = true;\n                if (removed) {\n                    leftLineNumber += 1;\n                    left.lineNumber = leftLineNumber;\n                    left.type = DiffType.REMOVED;\n                    left.value = line || ' ';\n                    // When the current line is of type REMOVED, check the next item in\n                    // the diff array whether it is of type ADDED. If true, the current\n                    // diff will be marked as both REMOVED and ADDED. Meaning, the\n                    // current line is a modification.\n                    const nextDiff = diffArray[diffIndex + 1];\n                    if (nextDiff && nextDiff.added) {\n                        const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n                        if (nextDiffLines) {\n                            const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n                            const { value: rightValue, lineNumber, type, } = nextDiffLineInfo[0].right;\n                            // When identified as modification, push the next diff to ignore\n                            // list as the next value will be added in this line computation as\n                            // right and left values.\n                            ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n                            right.lineNumber = lineNumber;\n                            if (left.value === rightValue) {\n                                // The new value is exactly the same as the old\n                                countAsChange = false;\n                                right.type = 0;\n                                left.type = 0;\n                                right.value = rightValue;\n                            }\n                            else {\n                                right.type = type;\n                                // Do char level diff and assign the corresponding values to the\n                                // left and right diff information object.\n                                if (disableWordDiff) {\n                                    right.value = rightValue;\n                                }\n                                else {\n                                    const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                                    right.value = computedDiff.right;\n                                    left.value = computedDiff.left;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    rightLineNumber += 1;\n                    right.lineNumber = rightLineNumber;\n                    right.type = DiffType.ADDED;\n                    right.value = line;\n                }\n                if (countAsChange && !evaluateOnlyFirstLine) {\n                    if (!diffLines.includes(counter)) {\n                        diffLines.push(counter);\n                    }\n                }\n            }\n            else {\n                leftLineNumber += 1;\n                rightLineNumber += 1;\n                left.lineNumber = leftLineNumber;\n                left.type = DiffType.DEFAULT;\n                left.value = line;\n                right.lineNumber = rightLineNumber;\n                right.type = DiffType.DEFAULT;\n                right.value = line;\n            }\n            if ((showLines === null || showLines === void 0 ? void 0 : showLines.includes(`L-${left.lineNumber}`)) || (showLines === null || showLines === void 0 ? void 0 : showLines.includes(`R-${right.lineNumber}`)) && !diffLines.includes(counter)) {\n                diffLines.push(counter);\n            }\n            if (!evaluateOnlyFirstLine) {\n                counter += 1;\n            }\n            return { right, left };\n        })\n            .filter(Boolean);\n    };\n    diffArray.forEach(({ added, removed, value }, index) => {\n        lineInformation = [\n            ...lineInformation,\n            ...getLineInformation(value, index, added, removed),\n        ];\n    });\n    return {\n        lineInformation,\n        diffLines,\n    };\n};\nexports.computeLineInformation = computeLineInformation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
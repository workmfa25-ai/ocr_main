{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\n\n/*istanbul ignore end*/\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction /*istanbul ignore start*/\n_default\n/*istanbul ignore end*/(start, minLine, maxLine) {\n  var wantForward = true,\n    backwardExhausted = false,\n    forwardExhausted = false,\n    localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n      forwardExhausted = true;\n    }\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}","map":{"version":3,"names":["_default","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","iterator"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\util\\distance-iterator.js"],"sourcesContent":["// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function(start, minLine, maxLine) {\n  let wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACe;AAAAA;AAAA,uBAAAA,CAASC,KAAT,EAAgBC,OAAhB,EAAyBC,OAAzB,EAAkC;EAC/C,IAAIC,WAAW,GAAG,IAAlB;IACIC,iBAAiB,GAAG,KADxB;IAEIC,gBAAgB,GAAG,KAFvB;IAGIC,WAAW,GAAG,CAHlB;EAKA,OAAO,SAASC,QAATA,CAAA,EAAoB;IACzB,IAAIJ,WAAW,IAAI,CAACE,gBAApB,EAAsC;MACpC,IAAID,iBAAJ,EAAuB;QACrBE,WAAW;MACZ,CAFD,MAEO;QACLH,WAAW,GAAG,KAAd;MACD,CALmC,CAOpC;MACA;;MACA,IAAIH,KAAK,GAAGM,WAAR,IAAuBJ,OAA3B,EAAoC;QAClC,OAAOI,WAAP;MACD;MAEDD,gBAAgB,GAAG,IAAnB;IACD;IAED,IAAI,CAACD,iBAAL,EAAwB;MACtB,IAAI,CAACC,gBAAL,EAAuB;QACrBF,WAAW,GAAG,IAAd;MACD,CAHqB,CAKtB;MACA;;MACA,IAAIF,OAAO,IAAID,KAAK,GAAGM,WAAvB,EAAoC;QAClC,OAAO,CAACA,WAAW,EAAnB;MACD;MAEDF,iBAAiB,GAAG,IAApB;MACA,OAAOG,QAAQ,EAAf;IACD,CA9BwB,CAgCzB;IACA;EACD,CAlCD;AAmCD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsePatch = parsePatch;\n\n/*istanbul ignore end*/\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/\n  var /*istanbul ignore end*/\n  options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n    delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n    list = [],\n    i = 0;\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n      chunkHeaderLine = diffstr[i++],\n      chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n    var addCount = 0,\n      removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n    return hunk;\n  }\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n  return list;\n}","map":{"version":3,"names":["parsePatch","uniDiff","options","arguments","length","undefined","diffstr","split","delimiters","match","list","i","parseIndex","index","push","line","test","header","exec","parseFileHeader","hunks","_line","parseHunk","strict","Error","JSON","stringify","fileHeader","keyPrefix","data","fileName","replace","substr","trim","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\patch\\parse.js"],"sourcesContent":["export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
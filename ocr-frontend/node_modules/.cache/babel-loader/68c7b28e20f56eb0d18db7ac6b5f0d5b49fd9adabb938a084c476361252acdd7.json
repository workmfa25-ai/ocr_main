{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffJson = diffJson;\nexports.canonicalize = canonicalize;\nexports.jsonDiff = void 0;\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/\n_base = _interopRequireDefault(require(\"./base\"))\n/*istanbul ignore end*/;\nvar /*istanbul ignore start*/\n_line = require(\"./line\")\n/*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n\n/*istanbul ignore end*/\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new /*istanbul ignore start*/\n_base\n/*istanbul ignore end*/[/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/](); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n/*istanbul ignore start*/\nexports.jsonDiff = jsonDiff;\n\n/*istanbul ignore end*/\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = /*istanbul ignore start*/\n_line\n/*istanbul ignore end*/. /*istanbul ignore start*/\nlineDiff\n/*istanbul ignore end*/.tokenize;\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/\n  var _this$options = /*istanbul ignore end*/\n    this.options,\n    undefinedReplacement = _this$options.undefinedReplacement,\n    _this$options$stringi = _this$options.stringifyReplacer,\n    stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) /*istanbul ignore start*/\n    {\n      return /*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function (left, right) {\n  return /*istanbul ignore start*/_base\n  /*istanbul ignore end*/[/*istanbul ignore start*/\n  \"default\"\n  /*istanbul ignore end*/].prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n  var i;\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n  var canonicalizedObj;\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n  if (/*istanbul ignore start*/\n  _typeof(/*istanbul ignore end*/\n  obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    var sortedKeys = [],\n      _key;\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}","map":{"version":3,"names":["_base","_interopRequireDefault","require","_line","objectPrototypeToString","Object","prototype","toString","jsonDiff","useLongestToken","tokenize","lineDiff","castInput","value","_this$options","options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","canonicalize","equals","left","right","call","replace","diffJson","oldObj","newObj","diff","obj","stack","replacementStack","replacer","key","i","length","canonicalizedObj","push","Array","pop","toJSON","_typeof","sortedKeys","_key","hasOwnProperty","sort"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\diff\\json.js"],"sourcesContent":["import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
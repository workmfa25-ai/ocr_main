{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.diffLines = diffLines;\nexports.diffTrimmedLines = diffTrimmedLines;\nexports.lineDiff = void 0;\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/\n_base = _interopRequireDefault(require(\"./base\"))\n/*istanbul ignore end*/;\nvar /*istanbul ignore start*/\n_params = require(\"../util/params\")\n/*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\n/*istanbul ignore end*/\nvar lineDiff = new /*istanbul ignore start*/\n_base\n/*istanbul ignore end*/[/*istanbul ignore start*/\n\"default\"\n/*istanbul ignore end*/]();\n\n/*istanbul ignore start*/\nexports.lineDiff = lineDiff;\n\n/*istanbul ignore end*/\nlineDiff.tokenize = function (value) {\n  if (this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n  var retLines = [],\n    linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n  return retLines;\n};\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = /*istanbul ignore start*/\n  (0, /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _params\n  /*istanbul ignore end*/. /*istanbul ignore start*/\n  generateOptions\n  /*istanbul ignore end*/)(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}","map":{"version":3,"names":["_base","_interopRequireDefault","require","_params","lineDiff","tokenize","value","options","stripTrailingCr","replace","retLines","linesAndNewlines","split","length","pop","i","line","newlineIsToken","ignoreWhitespace","trim","push","diffLines","oldStr","newStr","callback","diff","diffTrimmedLines","generateOptions"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\diff\\line.js"],"sourcesContent":["import Diff from './base';\nimport {generateOptions} from '../util/params';\n\nexport const lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n  if(this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  let retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    let line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nexport function diffLines(oldStr, newStr, callback) { return lineDiff.diff(oldStr, newStr, callback); }\nexport function diffTrimmedLines(oldStr, newStr, callback) {\n  let options = generateOptions(callback, {ignoreWhitespace: true});\n  return lineDiff.diff(oldStr, newStr, options);\n}\n"],"mappings":";;;;;;;;;;;AAAA;AAAAA,KAAA,GAAAC,sBAAA,CAAAC,OAAA;AAAA;AACA;AAAAC,OAAA,GAAAD,OAAA;AAAA;;;;;;;;;;AAEO,IAAME,QAAQ,GAAG,IAAI;AAAAJ;AAAA;AAAA;AAAA,wBAAJ,EAAjB;;;;;;AACPI,QAAQ,CAACC,QAAT,GAAoB,UAASC,KAAT,EAAgB;EAClC,IAAG,KAAKC,OAAL,CAAaC,eAAhB,EAAiC;IAC/B;IACAF,KAAK,GAAGA,KAAK,CAACG,OAAN,CAAc,OAAd,EAAuB,IAAvB,CAAR;EACD;EAED,IAAIC,QAAQ,GAAG,EAAf;IACIC,gBAAgB,GAAGL,KAAK,CAACM,KAAN,CAAY,WAAZ,CADvB,CANkC,CASlC;;EACA,IAAI,CAACD,gBAAgB,CAACA,gBAAgB,CAACE,MAAjB,GAA0B,CAA3B,CAArB,EAAoD;IAClDF,gBAAgB,CAACG,GAAjB;EACD,CAZiC,CAclC;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,gBAAgB,CAACE,MAArC,EAA6CE,CAAC,EAA9C,EAAkD;IAChD,IAAIC,IAAI,GAAGL,gBAAgB,CAACI,CAAD,CAA3B;IAEA,IAAIA,CAAC,GAAG,CAAJ,IAAS,CAAC,KAAKR,OAAL,CAAaU,cAA3B,EAA2C;MACzCP,QAAQ,CAACA,QAAQ,CAACG,MAAT,GAAkB,CAAnB,CAAR,IAAiCG,IAAjC;IACD,CAFD,MAEO;MACL,IAAI,KAAKT,OAAL,CAAaW,gBAAjB,EAAmC;QACjCF,IAAI,GAAGA,IAAI,CAACG,IAAL,EAAP;MACD;MACDT,QAAQ,CAACU,IAAT,CAAcJ,IAAd;IACD;EACF;EAED,OAAON,QAAP;AACD,CA7BD;AA+BO,SAASW,SAATA,CAAmBC,MAAnB,EAA2BC,MAA3B,EAAmCC,QAAnC,EAA6C;EAAE,OAAOpB,QAAQ,CAACqB,IAAT,CAAcH,MAAd,EAAsBC,MAAtB,EAA8BC,QAA9B,CAAP;AAAiD;AAChG,SAASE,gBAATA,CAA0BJ,MAA1B,EAAkCC,MAAlC,EAA0CC,QAA1C,EAAoD;EACzD,IAAIjB,OAAO,GAAG;EAAA;;EAAA;EAAAJ;EAAA;EAAAwB;EAAA,yBAAgBH,QAAhB,EAA0B;IAACN,gBAAgB,EAAE;EAAnB,CAA1B,CAAd;EACA,OAAOd,QAAQ,CAACqB,IAAT,CAAcH,MAAd,EAAsBC,MAAtB,EAA8BhB,OAA9B,CAAP;AACD","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
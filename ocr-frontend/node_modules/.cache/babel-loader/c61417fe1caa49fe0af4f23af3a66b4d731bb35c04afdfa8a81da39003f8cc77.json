{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = Diff;\n\n/*istanbul ignore end*/\nfunction Diff() {}\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var _options$timeout;\n    var /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n    var self = this;\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n      oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    var maxExecutionTime = /*istanbul ignore start*/\n    (_options$timeout = /*istanbul ignore end*/\n    options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;\n    var abortAfterTimestamp = Date.now() + maxExecutionTime;\n    var bestPath = [{\n      oldPos: -1,\n      lastComponent: undefined\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n\n    var minDiagonalToConsider = -Infinity,\n      maxDiagonalToConsider = Infinity; // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {\n        var basePath = /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/;\n        var removePath = bestPath[diagonalPath - 1],\n          addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          var addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n        var canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n\n        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  addToPath: function addToPath(path, added, removed, oldPosInc) {\n    var last = path.lastComponent;\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: last.count + 1,\n          added: added,\n          removed: removed,\n          previousComponent: last.previousComponent\n        }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {\n          count: 1,\n          added: added,\n          removed: removed,\n          previousComponent: last\n        }\n      };\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n      oldLen = oldString.length,\n      oldPos = basePath.oldPos,\n      newPos = oldPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n    if (commonCount) {\n      basePath.lastComponent = {\n        count: commonCount,\n        previousComponent: basePath.lastComponent\n      };\n    }\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  var components = [];\n  var nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n  var componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n  var finalComponent = components[componentLen - 1];\n  if (componentLen > 1 && typeof finalComponent.value === 'string' && (finalComponent.added || finalComponent.removed) && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n  return components;\n}","map":{"version":3,"names":["Diff","prototype","diff","oldString","newString","_options$timeout","options","arguments","length","undefined","callback","self","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","maxExecutionTime","timeout","Infinity","abortAfterTimestamp","Date","now","bestPath","oldPos","lastComponent","newPos","extractCommon","join","count","minDiagonalToConsider","maxDiagonalToConsider","execEditLength","diagonalPath","max","basePath","removePath","addPath","canAdd","addPathNewPos","canRemove","addToPath","buildValues","useLongestToken","exec","ret","path","added","removed","oldPosInc","last","previousComponent","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","push","split","chars","components","nextComponent","reverse","componentPos","componentLen","component","slice","map","oldValue","tmp","finalComponent","pop"],"sources":["D:\\Workspace\\ocr_main\\ocr-frontend\\node_modules\\diff\\src\\diff\\base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if(options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = options.timeout ?? Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n\n    let bestPath = [{ oldPos: -1, lastComponent: undefined }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (\n        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);\n        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);\n        diagonalPath += 2\n      ) {\n        let basePath;\n        let removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        let canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n        if (!canRemove || (canAdd && removePath.oldPos + 1 < addPath.oldPos)) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  addToPath(path, added, removed, oldPosInc) {\n    let last = path.lastComponent;\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: 1, added: added, removed: removed, previousComponent: last }\n      };\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.lastComponent = {count: commonCount, previousComponent: basePath.lastComponent};\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  const components = [];\n  let nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let finalComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof finalComponent.value === 'string'\n      && (finalComponent.added || finalComponent.removed)\n      && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}